<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hiko</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://machu.club/"/>
  <updated>2019-10-18T17:36:53.423Z</updated>
  <id>http://machu.club/</id>
  
  <author>
    <name>Hiko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>idea 通过跳板机 远程debug</title>
    <link href="http://machu.club/2019/10/18/idea%20%E9%80%9A%E8%BF%87%E8%B7%B3%E6%9D%BF%E6%9C%BA%20%E8%BF%9C%E7%A8%8Bdebug/"/>
    <id>http://machu.club/2019/10/18/idea 通过跳板机 远程debug/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2019-10-18T17:36:53.423Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先在 java 启动的时候加上参数:  指定一个端口 (以下为5066 )</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5066 -jar</span><br></pre></td></tr></table></figure></p><p><strong>然后通过远程建立ssh通道将本地的5066,代理到服务机的5066端口上:</strong><br><img src="http://pic.machu.club/7B7A6C95-FDCE-41EA-81C8-2CBBA264688E.png" alt="fbebf4d4e38d675a257ba74843e226ad.png"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -l <span class="variable">$JUMP_SERVER_USER</span> -L 5066:<span class="variable">$SERVER_IP</span>:5066 -p <span class="variable">$JUMP_SERVER_PORT</span> <span class="variable">$JUMP_SERVER_IP</span></span><br></pre></td></tr></table></figure></p><ul><li>JUMP_SERVER_USER : 是跳板机账号</li><li>SERVER_IP : 是服务器的ip，跳板机通过该ip可连接到服务器</li><li>JUMP_SERVER_PORT : 是指跳板机的ssh端口</li><li>JUMP_SERVER_IP : 是指跳板机的ip</li></ul><p><strong>然后idea上配置远程debug后启动即可</strong></p><p><img src="http://pic.machu.club/01C0C1C9-3B6C-401C-9791-77D90805D528.png" alt="fa01c4506935523fb577211b575963b8.png"></p><p><strong>成功</strong><br><img src="http://pic.machu.club/E9755145-FA55-4D07-99B0-D785A224A5C6.png" alt="64125b2a2bb457c6c51c64955dd45c5f.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;首先在 java 启动的时候加上参数:  指定一个端口 (以下为5066 )&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://machu.club/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="idea" scheme="http://machu.club/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型  -  Java memory model</title>
    <link href="http://machu.club/2019/09/18/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%20%20-%20%20Java%20memory%20model/"/>
    <id>http://machu.club/2019/09/18/Java内存模型  -  Java memory model/</id>
    <published>2019-09-17T16:00:00.000Z</published>
    <updated>2019-10-18T17:36:56.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的内存结构，也就是运行时的数据区域："><a href="#Java的内存结构，也就是运行时的数据区域：" class="headerlink" title="Java的内存结构，也就是运行时的数据区域："></a>Java的内存结构，也就是运行时的数据区域：</h2><p><img src="http://pic.machu.club/33824419-2CE7-4D17-BA98-22933CB80E7C.png" alt="fe1abe8a5220acf543c1aaf98ab5bedb.png"></p><h3 id="pc寄存器／程序计数器"><a href="#pc寄存器／程序计数器" class="headerlink" title="pc寄存器／程序计数器"></a>pc寄存器／程序计数器</h3><p>每个线程都需要有一个独立的程序计数器</p><h3 id="Java栈-Java-stack"><a href="#Java栈-Java-stack" class="headerlink" title="Java栈(Java stack)"></a>Java栈(Java stack)</h3><ul><li>每创建一个线程，创建对应的Java栈</li><li>每一个Java栈中包含多个栈帧(Stack Frame)</li><li>栈帧会含有一些局部变量、操作栈和方法返回值等信息</li><li>每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧</li><li>Java栈的栈顶的栈帧就是当前正在执行的活动栈(正在执行的方法)</li><li>PC寄存器也会指向该地址</li><li>只有这个活动的栈帧的本地变量可以被操作栈使用</li><li>在这个栈帧中调用另一个方法时,新创建的栈帧会被放到栈顶,这个方法运行完时,栈帧被移除,之前的栈帧被重新变为活动栈,且调用方法的返回值会成为这个栈帧操作栈中的一个操作数</li></ul><p><img src="http://pic.machu.club/57BD88FF-5694-4CB5-B34B-5F0E04E343F0.png" alt="684fe763be5087cd7919448796f585c6.png"></p><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><ul><li>Jvm里内存最大的一块,启动时创建</li><li>被所有Java线程锁共享,不是线程安全</li><li>存储Java对象的地方</li><li>所有的对象实例以及数组都要在堆上分配</li><li>Java堆是GC管理的主要区域</li></ul><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><ul><li>存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息</li><li>当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区</li><li>被Java线程锁共享的</li><li>不会频繁被GC回收，在一定条件下会被GC</li><li>也是堆中的一部分，通常所说的Java堆中的永久区 Permanet Generation</li></ul><h3 id="常量池-Constant-Pool"><a href="#常量池-Constant-Pool" class="headerlink" title="常量池(Constant Pool)"></a>常量池(Constant Pool)</h3><ul><li>本身是方法区中的一个数据结构。</li><li>存储了如字符串、final变量值、类名和方法名常量。</li><li>在编译期间就被确定，并保存在已编译的.class文件中。</li><li>一般分为两类：字面量和引用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定位到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。</li></ul><h3 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h3><ul><li>和Java栈所发挥的作用非常相似</li><li>区别:Java栈为JVM执行Java方法服务,本地方法栈为JVM执行Native方法服务</li></ul><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p><em>Monitor</em></p><ul><li>所有的变量都存储在主内存（Main Memory）中</li><li>每个线程还有自己的工作内存（Working Memory），线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝</li><li>线程之间值的传递都需要通过主内存来完成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java的内存结构，也就是运行时的数据区域：&quot;&gt;&lt;a href=&quot;#Java的内存结构，也就是运行时的数据区域：&quot; class=&quot;headerlink&quot; title=&quot;Java的内存结构，也就是运行时的数据区域：&quot;&gt;&lt;/a&gt;Java的内存结构，也就是运行时的数据区
      
    
    </summary>
    
      <category term="知识点" scheme="http://machu.club/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Java" scheme="http://machu.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>安装Centos minimal及一些服务设置</title>
    <link href="http://machu.club/2018/04/05/%E5%AE%89%E8%A3%85Centos%20minimal%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE/"/>
    <id>http://machu.club/2018/04/05/安装Centos minimal及一些服务设置/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2019-10-19T04:23:06.839Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统版本：</strong> CentOS-6.8-x86_64-minimal</p><h4 id="因为装的是minimal版本-所以系统装好后-并连不上网络需要设置一下如下"><a href="#因为装的是minimal版本-所以系统装好后-并连不上网络需要设置一下如下" class="headerlink" title="因为装的是minimal版本,所以系统装好后,并连不上网络需要设置一下如下:"></a>因为装的是minimal版本,所以系统装好后,并连不上网络需要设置一下如下:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  <span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line">☁  ~  vi ifcfg-eth0</span><br></pre></td></tr></table></figure><p>将ONBOOT=no改为了yes</p><p>然后重启网络服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  service network restart</span><br></pre></td></tr></table></figure><h4 id="查看是否安装ssh"><a href="#查看是否安装ssh" class="headerlink" title="查看是否安装ssh"></a>查看是否安装ssh</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  yum list installed | grep openssh</span><br></pre></td></tr></table></figure><p>如没有安装 则使用以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  yum install openssh</span><br></pre></td></tr></table></figure><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  useradd -d /home/hiko hiko</span><br><span class="line">☁  ~  passwd hiko</span><br></pre></td></tr></table></figure><p>若新建用户无ssh权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>添加 <code>AllowUsers:hiko</code></p><p><strong>赋予root权限</strong><br>方法一：修改 <code>/etc/sudoers</code> 文件,找到以下两行,去掉第二行的 <code>#</code>去掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##Allows people in group wheel to run all commands</span></span><br><span class="line">%wheel            ALL=(ALL)           ALL</span><br></pre></td></tr></table></figure><p>然后修改用户，使其属于<code>root</code>组（wheel），命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  usermod -g root hiko</span><br></pre></td></tr></table></figure><p>修改完后，使用hiko帐号登录，命令<code>su -</code>，即可获得root权限。</p><p>方法二：修改 <code>/etc/sudoers</code> 文件,找到以下内容在,root下面一行添加 hiko用户配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Allow root to run any commands anywhere </span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">hiko    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>修改完后，使用hiko帐号登录，命令<code>su -</code>，即可获得root权限。</p><h4 id="ssh登录免密"><a href="#ssh登录免密" class="headerlink" title="ssh登录免密"></a>ssh登录免密</h4><p>使用ssh-keygen命令创建密钥对<br>假设 我现在需要在A机(192.168.1.1)上免密ssh登录到B(192.168.1.2)机</p><p>在A机用户路径中的.ssh文件夹内创建密钥对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  ssh-keygen -t rsa -f id_rsa.xxx  -P <span class="string">''</span></span><br></pre></td></tr></table></figure><ul><li><strong><em>-f 命名生成的文件名称</em></strong></li><li><strong><em>-P ‘’ 无密码 （不加则需要输入三次回车）</em></strong></li></ul><p>这时候.ssh文件夹下会生成两个文件(id_rsa.xxx id_rsa.xxx.pub)</p><p>将id_rsa.xxx.pub 用scp命令传输的B上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  scp id_rsa.xxx.pub root@192.168.1.2:/(B机上.ssh的路径)</span><br></pre></td></tr></table></figure><p>将id_rsa.xxx.pub里的内容写入到 .ssh中的authorized_keys文件中(没有则创建),并修改authorized_keys文件和.ssh文件夹的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  cat id_rsa.xxx.pub&gt;&gt;authorized_keys</span><br><span class="line">☁  ~  chmod 600 authorized_keys</span><br><span class="line">☁  ~  chmod 700 -R .ssh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;系统版本：&lt;/strong&gt; CentOS-6.8-x86_64-minimal&lt;/p&gt;
&lt;h4 id=&quot;因为装的是minimal版本-所以系统装好后-并连不上网络需要设置一下如下&quot;&gt;&lt;a href=&quot;#因为装的是minimal版本-所以系统装好后-并连不上
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://machu.club/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://machu.club/tags/linux/"/>
    
  </entry>
  
</feed>
