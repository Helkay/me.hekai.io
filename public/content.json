{"meta":{"title":"Hiko","subtitle":null,"description":null,"author":"Hiko","url":"http://machu.club","root":"/"},"pages":[],"posts":[{"title":"idea 通过跳板机 远程debug","slug":"idea 通过跳板机 远程debug","date":"2019-10-17T16:00:00.000Z","updated":"2019-10-18T17:36:53.423Z","comments":false,"path":"2019/10/18/idea 通过跳板机 远程debug/","link":"","permalink":"http://machu.club/2019/10/18/idea 通过跳板机 远程debug/","excerpt":"","text":"首先在 java 启动的时候加上参数: 指定一个端口 (以下为5066 )1Java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5066 -jar 然后通过远程建立ssh通道将本地的5066,代理到服务机的5066端口上:1ssh -l $JUMP_SERVER_USER -L 5066:$SERVER_IP:5066 -p $JUMP_SERVER_PORT $JUMP_SERVER_IP JUMP_SERVER_USER : 是跳板机账号 SERVER_IP : 是服务器的ip，跳板机通过该ip可连接到服务器 JUMP_SERVER_PORT : 是指跳板机的ssh端口 JUMP_SERVER_IP : 是指跳板机的ip 然后idea上配置远程debug后启动即可 成功","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://machu.club/categories/技术笔记/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://machu.club/tags/idea/"}]},{"title":"Java内存模型  -  Java memory model","slug":"Java内存模型  -  Java memory model","date":"2019-09-17T16:00:00.000Z","updated":"2019-10-19T04:35:17.945Z","comments":false,"path":"2019/09/18/Java内存模型  -  Java memory model/","link":"","permalink":"http://machu.club/2019/09/18/Java内存模型  -  Java memory model/","excerpt":"","text":"Java的内存结构，也就是运行时的数据区域： pc寄存器／程序计数器每个线程都需要有一个独立的程序计数器 Java栈(Java stack) 每创建一个线程，创建对应的Java栈 每一个Java栈中包含多个栈帧(Stack Frame) 栈帧会含有一些局部变量、操作栈和方法返回值等信息 每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧 Java栈的栈顶的栈帧就是当前正在执行的活动栈(正在执行的方法) PC寄存器也会指向该地址 只有这个活动的栈帧的本地变量可以被操作栈使用 在这个栈帧中调用另一个方法时,新创建的栈帧会被放到栈顶,这个方法运行完时,栈帧被移除,之前的栈帧被重新变为活动栈,且调用方法的返回值会成为这个栈帧操作栈中的一个操作数 堆(Heap) Jvm里内存最大的一块,启动时创建 被所有Java线程锁共享,不是线程安全 存储Java对象的地方 所有的对象实例以及数组都要在堆上分配 Java堆是GC管理的主要区域 方法区(Method Area) 存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息 当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区 被Java线程锁共享的 不会频繁被GC回收，在一定条件下会被GC 也是堆中的一部分，通常所说的Java堆中的永久区 Permanet Generation 常量池(Constant Pool) 本身是方法区中的一个数据结构。 存储了如字符串、final变量值、类名和方法名常量。 在编译期间就被确定，并保存在已编译的.class文件中。 一般分为两类：字面量和引用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定位到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。 本地方法栈(Native Method Stack) 和Java栈所发挥的作用非常相似 区别:Java栈为JVM执行Java方法服务,本地方法栈为JVM执行Native方法服务 JMM主内存和工作内存Monitor 所有的变量都存储在主内存（Main Memory）中 每个线程还有自己的工作内存（Working Memory），线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝 线程之间值的传递都需要通过主内存来完成","categories":[{"name":"知识点","slug":"知识点","permalink":"http://machu.club/categories/知识点/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://machu.club/tags/Java/"}]},{"title":"linux 服务器下 docker 初体验","slug":"linux 服务器下 docker 初体验","date":"2018-05-09T16:00:00.000Z","updated":"2019-10-19T04:36:05.020Z","comments":false,"path":"2018/05/10/linux 服务器下 docker 初体验/","link":"","permalink":"http://machu.club/2018/05/10/linux 服务器下 docker 初体验/","excerpt":"","text":"系统版本:** CentOS-7-x86_64-Minimal-1804 安装docker使用 yum install docker 命令安装docker 使用非centos 7的版本可能会报以下错误 No package docker available 没有找到docker包,需要第三方软件库epel,使用一下以下命令安装 1☁ ~ sudo yum install epel-release 然后再安装 1☁ ~ sudo yum install docker-io 修改国内docker加速配置1☁ ~ vim /etc/docker/daemon.json 修改 &quot;registry-mirrors&quot; 为相应的国内加速地址 修改好配置文件后，重新加载并启动 12☁ ~ systemctl daemon-reload☁ ~ systemctl restart docker 以下我会以在docker中使用jenkins为例,列举docker的一些基本使用方法 下载jenkins镜像 1☁ ~ docker pull jenkins 创建jenkins文件夹 用来做挂载磁盘 1☁ ~ mkdir /home/hiko/jenkins 注意：在安装jenkins时候，挂在文件夹/home/hzq/jenkins/的归属用户id必须是1000，否则会抛出无操作权限异常。 查看文件夹属性 1☁ ~ ls -nd /home/hiko/jenkins/ 修改文件夹 归属者 和 组 1☁ ~ chown -R 1000:1000 jenkins/ 启动jenkins 1☁ ~ docker run -itd -p 8080:8080 -p 50000:50000 --name jenkins --privileged=true -v /home/hiko/jenkins:/var/jenkins_home jenkins -p 8080:8080 -p 50000:50000 : 映射端口 --privileged=true : 在CentOS7中的安全模块selinux把权限禁掉了，参数给容器加权。 -v /home/hiko/jenkins:/var/jenkins_home : 磁盘挂载 查看containers储存地址12☁ ~ cd /var/lib/docker/containers/ &#123;container_ID&#125;☁ ~ vi config.v2.json 自定义挂载: 123456789101112131415161718&#123; \"MountPoints\": &#123; \"/var/jenkins_home\": &#123; \"Source\": \"/home/hiko/jenkins\", \"Destination\": \"/var/jenkins_home\", \"RW\": true, \"Name\": \"\", \"Driver\": \"\", \"Type\": \"bind\", \"Propagation\": \"rprivate\", \"Spec\": &#123; \"Type\": \"bind\", \"Source\": \"/home/hiko/jenkins\", \"Target\": \"/var/jenkins_home\" &#125; &#125; &#125;&#125; 如果不挂载磁盘,则默认启动后地址: 12345678910111213&#123; \"MountPoints\": &#123; \"/var/jenkins_home\": &#123; \"Source\": \"\", \"Destination\": \"/var/jenkins_home\", \"RW\": true, \"Name\": \"d48f1035be1c76267a404c4fea29ef2f709bdff0ddf0736356cbd4897c7bc87b\", \"Driver\": \"local\", \"Type\": \"volume\", \"Spec\": &#123;&#125; &#125; &#125;&#125; 1☁ ~ cd /var/lib/docker/volumes docker进入容器的几种办法 docker attach使用 docker attach 想要进入命令行界面,有个前提是这个容器必须是用 /bin/bash 创建的。参考资料: difference between docker attach and docker exec SSH nsenter github链接 docker exec 1☁ ~ docker exec -it 775c7c9ee1e1 /bin/bash ##docker rm命令-删除一个或多个容器 显示所有的容器，过滤出Exited状态的容器，取出这些容器的ID， 1☁ ~ docker ps -a | grep Exited|awk '&#123;print $1&#125;' 查询所有的容器，过滤出Exited状态的容器，列出容器ID，删除这些容器 1☁ ~ docker rm `docker ps -a | grep Exited | awk '&#123;print $1&#125;'`","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://machu.club/categories/技术笔记/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://machu.club/tags/Docker/"}]},{"title":"安装Centos minimal及一些服务设置","slug":"安装Centos minimal及一些服务设置","date":"2018-04-04T16:00:00.000Z","updated":"2019-10-19T04:23:06.839Z","comments":false,"path":"2018/04/05/安装Centos minimal及一些服务设置/","link":"","permalink":"http://machu.club/2018/04/05/安装Centos minimal及一些服务设置/","excerpt":"","text":"系统版本： CentOS-6.8-x86_64-minimal 因为装的是minimal版本,所以系统装好后,并连不上网络需要设置一下如下:12☁ ~ cd /etc/sysconfig/network-scripts/☁ ~ vi ifcfg-eth0 将ONBOOT=no改为了yes 然后重启网络服务 1☁ ~ service network restart 查看是否安装ssh1☁ ~ yum list installed | grep openssh 如没有安装 则使用以下命令: 1☁ ~ yum install openssh 新建用户12☁ ~ useradd -d /home/hiko hiko☁ ~ passwd hiko 若新建用户无ssh权限 1vim /etc/ssh/sshd_config 添加 AllowUsers:hiko 赋予root权限方法一：修改 /etc/sudoers 文件,找到以下两行,去掉第二行的 #去掉 12##Allows people in group wheel to run all commands%wheel ALL=(ALL) ALL 然后修改用户，使其属于root组（wheel），命令如下: 1☁ ~ usermod -g root hiko 修改完后，使用hiko帐号登录，命令su -，即可获得root权限。 方法二：修改 /etc/sudoers 文件,找到以下内容在,root下面一行添加 hiko用户配置: 123## Allow root to run any commands anywhere root ALL=(ALL) ALLhiko ALL=(ALL) ALL 修改完后，使用hiko帐号登录，命令su -，即可获得root权限。 ssh登录免密使用ssh-keygen命令创建密钥对假设 我现在需要在A机(192.168.1.1)上免密ssh登录到B(192.168.1.2)机 在A机用户路径中的.ssh文件夹内创建密钥对 1☁ ~ ssh-keygen -t rsa -f id_rsa.xxx -P '' -f 命名生成的文件名称 -P ‘’ 无密码 （不加则需要输入三次回车） 这时候.ssh文件夹下会生成两个文件(id_rsa.xxx id_rsa.xxx.pub) 将id_rsa.xxx.pub 用scp命令传输的B上 1☁ ~ scp id_rsa.xxx.pub root@192.168.1.2:/(B机上.ssh的路径) 将id_rsa.xxx.pub里的内容写入到 .ssh中的authorized_keys文件中(没有则创建),并修改authorized_keys文件和.ssh文件夹的权限 123☁ ~ cat id_rsa.xxx.pub&gt;&gt;authorized_keys☁ ~ chmod 600 authorized_keys☁ ~ chmod 700 -R .ssh","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://machu.club/categories/技术笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://machu.club/tags/linux/"}]}]}