{"meta":{"title":"Hiko","subtitle":null,"description":null,"author":"Hiko","url":"http://machu.club","root":"/"},"pages":[],"posts":[{"title":"idea 通过跳板机 远程debug","slug":"idea 通过跳板机 远程debug","date":"2019-10-17T16:00:00.000Z","updated":"2019-10-18T17:36:53.423Z","comments":false,"path":"2019/10/18/idea 通过跳板机 远程debug/","link":"","permalink":"http://machu.club/2019/10/18/idea 通过跳板机 远程debug/","excerpt":"","text":"首先在 java 启动的时候加上参数: 指定一个端口 (以下为5066 )1Java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5066 -jar 然后通过远程建立ssh通道将本地的5066,代理到服务机的5066端口上:1ssh -l $JUMP_SERVER_USER -L 5066:$SERVER_IP:5066 -p $JUMP_SERVER_PORT $JUMP_SERVER_IP JUMP_SERVER_USER : 是跳板机账号 SERVER_IP : 是服务器的ip，跳板机通过该ip可连接到服务器 JUMP_SERVER_PORT : 是指跳板机的ssh端口 JUMP_SERVER_IP : 是指跳板机的ip 然后idea上配置远程debug后启动即可 成功","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://machu.club/categories/技术笔记/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://machu.club/tags/idea/"}]},{"title":"Java内存模型  -  Java memory model","slug":"Java内存模型  -  Java memory model","date":"2019-09-17T16:00:00.000Z","updated":"2019-10-19T04:35:17.945Z","comments":false,"path":"2019/09/18/Java内存模型  -  Java memory model/","link":"","permalink":"http://machu.club/2019/09/18/Java内存模型  -  Java memory model/","excerpt":"","text":"Java的内存结构，也就是运行时的数据区域： pc寄存器／程序计数器每个线程都需要有一个独立的程序计数器 Java栈(Java stack) 每创建一个线程，创建对应的Java栈 每一个Java栈中包含多个栈帧(Stack Frame) 栈帧会含有一些局部变量、操作栈和方法返回值等信息 每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧 Java栈的栈顶的栈帧就是当前正在执行的活动栈(正在执行的方法) PC寄存器也会指向该地址 只有这个活动的栈帧的本地变量可以被操作栈使用 在这个栈帧中调用另一个方法时,新创建的栈帧会被放到栈顶,这个方法运行完时,栈帧被移除,之前的栈帧被重新变为活动栈,且调用方法的返回值会成为这个栈帧操作栈中的一个操作数 堆(Heap) Jvm里内存最大的一块,启动时创建 被所有Java线程锁共享,不是线程安全 存储Java对象的地方 所有的对象实例以及数组都要在堆上分配 Java堆是GC管理的主要区域 方法区(Method Area) 存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息 当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区 被Java线程锁共享的 不会频繁被GC回收，在一定条件下会被GC 也是堆中的一部分，通常所说的Java堆中的永久区 Permanet Generation 常量池(Constant Pool) 本身是方法区中的一个数据结构。 存储了如字符串、final变量值、类名和方法名常量。 在编译期间就被确定，并保存在已编译的.class文件中。 一般分为两类：字面量和引用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定位到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。 本地方法栈(Native Method Stack) 和Java栈所发挥的作用非常相似 区别:Java栈为JVM执行Java方法服务,本地方法栈为JVM执行Native方法服务 JMM主内存和工作内存Monitor 所有的变量都存储在主内存（Main Memory）中 每个线程还有自己的工作内存（Working Memory），线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝 线程之间值的传递都需要通过主内存来完成","categories":[{"name":"知识点","slug":"知识点","permalink":"http://machu.club/categories/知识点/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://machu.club/tags/Java/"}]},{"title":"linux 服务器下 docker 初体验","slug":"linux 服务器下 docker 初体验","date":"2018-05-09T16:00:00.000Z","updated":"2019-10-19T04:36:25.397Z","comments":false,"path":"2018/05/10/linux 服务器下 docker 初体验/","link":"","permalink":"http://machu.club/2018/05/10/linux 服务器下 docker 初体验/","excerpt":"","text":"系统版本:** CentOS-7-x86_64-Minimal-1804 安装docker使用 yum install docker 命令安装docker 使用非centos 7的版本可能会报以下错误 No package docker available 没有找到docker包,需要第三方软件库epel,使用一下以下命令安装 1☁ ~ sudo yum install epel-release 然后再安装 1☁ ~ sudo yum install docker-io 修改国内docker加速配置1☁ ~ vim /etc/docker/daemon.json 修改 &quot;registry-mirrors&quot; 为相应的国内加速地址 修改好配置文件后，重新加载并启动 12☁ ~ systemctl daemon-reload☁ ~ systemctl restart docker 以下我会以在docker中使用jenkins为例,列举docker的一些基本使用方法 下载jenkins镜像 1☁ ~ docker pull jenkins 创建jenkins文件夹 用来做挂载磁盘 1☁ ~ mkdir /home/hiko/jenkins 注意：在安装jenkins时候，挂在文件夹/home/hzq/jenkins/的归属用户id必须是1000，否则会抛出无操作权限异常。 查看文件夹属性 1☁ ~ ls -nd /home/hiko/jenkins/ 修改文件夹 归属者 和 组 1☁ ~ chown -R 1000:1000 jenkins/ 启动jenkins 1☁ ~ docker run -itd -p 8080:8080 -p 50000:50000 --name jenkins --privileged=true -v /home/hiko/jenkins:/var/jenkins_home jenkins -p 8080:8080 -p 50000:50000 : 映射端口 --privileged=true : 在CentOS7中的安全模块selinux把权限禁掉了，参数给容器加权。 -v /home/hiko/jenkins:/var/jenkins_home : 磁盘挂载 查看containers储存地址12☁ ~ cd /var/lib/docker/containers/ &#123;container_ID&#125;☁ ~ vi config.v2.json 自定义挂载: 123456789101112131415161718&#123; \"MountPoints\": &#123; \"/var/jenkins_home\": &#123; \"Source\": \"/home/hiko/jenkins\", \"Destination\": \"/var/jenkins_home\", \"RW\": true, \"Name\": \"\", \"Driver\": \"\", \"Type\": \"bind\", \"Propagation\": \"rprivate\", \"Spec\": &#123; \"Type\": \"bind\", \"Source\": \"/home/hiko/jenkins\", \"Target\": \"/var/jenkins_home\" &#125; &#125; &#125;&#125; 如果不挂载磁盘,则默认启动后地址: 12345678910111213&#123; \"MountPoints\": &#123; \"/var/jenkins_home\": &#123; \"Source\": \"\", \"Destination\": \"/var/jenkins_home\", \"RW\": true, \"Name\": \"d48f1035be1c76267a404c4fea29ef2f709bdff0ddf0736356cbd4897c7bc87b\", \"Driver\": \"local\", \"Type\": \"volume\", \"Spec\": &#123;&#125; &#125; &#125;&#125; 1☁ ~ cd /var/lib/docker/volumes docker进入容器的几种办法 docker attach使用 docker attach 想要进入命令行界面,有个前提是这个容器必须是用 /bin/bash 创建的。参考资料: difference between docker attach and docker exec SSH nsenter github链接 docker exec 1☁ ~ docker exec -it 775c7c9ee1e1 /bin/bash ##docker rm命令-删除一个或多个容器 显示所有的容器，过滤出Exited状态的容器，取出这些容器的ID， 1☁ ~ docker ps -a | grep Exited|awk '&#123;print $1&#125;' 查询所有的容器，过滤出Exited状态的容器，列出容器ID，删除这些容器 1☁ ~ docker rm `docker ps -a | grep Exited | awk '&#123;print $1&#125;'`","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://machu.club/categories/技术笔记/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://machu.club/tags/Docker/"}]},{"title":"安装Centos minimal及一些服务设置","slug":"安装Centos minimal及一些服务设置","date":"2018-04-04T16:00:00.000Z","updated":"2019-10-19T04:23:06.839Z","comments":false,"path":"2018/04/05/安装Centos minimal及一些服务设置/","link":"","permalink":"http://machu.club/2018/04/05/安装Centos minimal及一些服务设置/","excerpt":"","text":"系统版本： CentOS-6.8-x86_64-minimal 因为装的是minimal版本,所以系统装好后,并连不上网络需要设置一下如下:12☁ ~ cd /etc/sysconfig/network-scripts/☁ ~ vi ifcfg-eth0 将ONBOOT=no改为了yes 然后重启网络服务 1☁ ~ service network restart 查看是否安装ssh1☁ ~ yum list installed | grep openssh 如没有安装 则使用以下命令: 1☁ ~ yum install openssh 新建用户12☁ ~ useradd -d /home/hiko hiko☁ ~ passwd hiko 若新建用户无ssh权限 1vim /etc/ssh/sshd_config 添加 AllowUsers:hiko 赋予root权限方法一：修改 /etc/sudoers 文件,找到以下两行,去掉第二行的 #去掉 12##Allows people in group wheel to run all commands%wheel ALL=(ALL) ALL 然后修改用户，使其属于root组（wheel），命令如下: 1☁ ~ usermod -g root hiko 修改完后，使用hiko帐号登录，命令su -，即可获得root权限。 方法二：修改 /etc/sudoers 文件,找到以下内容在,root下面一行添加 hiko用户配置: 123## Allow root to run any commands anywhere root ALL=(ALL) ALLhiko ALL=(ALL) ALL 修改完后，使用hiko帐号登录，命令su -，即可获得root权限。 ssh登录免密使用ssh-keygen命令创建密钥对假设 我现在需要在A机(192.168.1.1)上免密ssh登录到B(192.168.1.2)机 在A机用户路径中的.ssh文件夹内创建密钥对 1☁ ~ ssh-keygen -t rsa -f id_rsa.xxx -P '' -f 命名生成的文件名称 -P ‘’ 无密码 （不加则需要输入三次回车） 这时候.ssh文件夹下会生成两个文件(id_rsa.xxx id_rsa.xxx.pub) 将id_rsa.xxx.pub 用scp命令传输的B上 1☁ ~ scp id_rsa.xxx.pub root@192.168.1.2:/(B机上.ssh的路径) 将id_rsa.xxx.pub里的内容写入到 .ssh中的authorized_keys文件中(没有则创建),并修改authorized_keys文件和.ssh文件夹的权限 123☁ ~ cat id_rsa.xxx.pub&gt;&gt;authorized_keys☁ ~ chmod 600 authorized_keys☁ ~ chmod 700 -R .ssh","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://machu.club/categories/技术笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://machu.club/tags/linux/"}]},{"title":"Java核心技术 - 基础知识","slug":"2017/11/Java核心技术 - 基础知识","date":"2017-11-09T16:00:00.000Z","updated":"2017-11-10T04:54:38.000Z","comments":true,"path":"2017/11/10/2017/11/Java核心技术 - 基础知识/","link":"","permalink":"http://machu.club/2017/11/10/2017/11/Java核心技术 - 基础知识/","excerpt":"","text":"printf转换符","categories":[{"name":"Java","slug":"Java","permalink":"http://machu.club/categories/Java/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/tags/Blog/"}]},{"title":"计算机基础之位运算","slug":"2017/10/计算机基础之位运算","date":"2017-10-24T16:00:00.000Z","updated":"2017-11-10T04:14:35.000Z","comments":true,"path":"2017/10/25/2017/10/计算机基础之位运算/","link":"","permalink":"http://machu.club/2017/10/25/2017/10/计算机基础之位运算/","excerpt":"","text":"二进制机器数 一个数在计算机中的二进制表示形式,叫做这个数的机器数。 机器数是带符号的,在计算机用一个数的 最高位 存放符号, 正数为0, 负数为1. 比如,十进制中的数 +3,计算机字长为8位,转换成二进制就是00000011.如果是 -3,就是 10000011 . 那么，这里的 00000011 和 10000011 就是机器数。 原码 原码就是 符号位 加上真值的绝对值 123[+1]原 = 0000 0001[-1]原 = 1000 0001 反码 正数的反码是其本身 负数的反码是在其原码的基础上,符号位不变,其余各个位取反. 123[+1] = [00000001]原 = [00000001]反[-1] = [10000001]原 = [11111110]反 补码 正数的补码就是其本身. 负数的补码是在其原码的基础上,符号位不变,其余各位取反,最后+1. (即在反码的基础上+1) 123[+1] = [00000001]原 = [00000001]反 = [00000001]补[-1] = [10000001]原 = [11111110]反 = [11111111]补 与（&amp;）运算符 两个操作数中位都为1，结果才为1，否则结果为0 1234 : 1007 : 111a &amp; b = 4 : 100 或（|）运算符 两个操作数中位只要有一个为1，那么结果就是1，否则就为0 1234 : 1007 : 111a | b = 7 : 111 非运算符 非运算符用符号“~”表示，其运算规律如下: 如果位为0，结果是1，如果位为1，结果是0 124 : 00000000 00000000 00000000 00000100~a = -5 : 11111111 11111111 11111111 11111011 异或运算符 异或运算符用符号“^”表示，其运算规律如下: 异或的概念是相同为0不同为1 1233 : 0114 : 1003^4 = 7 : 111 “&lt;&lt;”和”&gt;&gt;”运算符 将二进制位 进行左位移和右位移操作 12311 : 101111&lt;&lt;3 : 101100011&gt;&gt;3 : 0001 “&gt;&gt;&gt;”运算符 “&gt;&gt;&gt;”运算符将用0填充高位 12-11 : 1111111111111111111111111111010111&gt;&gt;&gt;3 : 00011111111111111111111111111110","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://machu.club/tags/计算机基础/"}]},{"title":"spring aop事务","slug":"2017/06/spring aop事务","date":"2017-06-28T16:00:00.000Z","updated":"2017-06-29T05:06:29.000Z","comments":true,"path":"2017/06/29/2017/06/spring aop事务/","link":"","permalink":"http://machu.club/2017/06/29/2017/06/spring aop事务/","excerpt":"","text":"由于今天项目配置了spring aop事务发现不生效,检查配置文件如下没有问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"mysqlTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 使用annotation注解方式配置事务 --&gt; &lt;tx:annotation-driven transaction-manager=\"mysqlTransactionManager\"/&gt; &lt;!-- AOP配置事物 --&gt; &lt;tx:advice id=\"mysqlTransactionAdvice\" transaction-manager=\"mysqlTransactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"query*\" read-only=\"true\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"add*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"rollBack*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置AOP切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"mysqlTransactionPointCut\" expression=\"execution(* com.at.service.impl.*.*(..))\"/&gt; &lt;aop:advisor pointcut-ref=\"mysqlTransactionPointCut\" advice-ref=\"mysqlTransactionAdvice\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 网上查询了下资料,发现是由于mysql数据库存储引擎导致的, MyISAM不支持事务,需要修改成InnoDB 查看 1show table status; 修改 1alter table table_name engine=innodb;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://machu.club/tags/Spring/"}]},{"title":"mysql快速复制数据库","slug":"2017/06/mysql快速复制数据库","date":"2017-06-19T16:00:00.000Z","updated":"2017-06-20T03:35:54.000Z","comments":true,"path":"2017/06/20/2017/06/mysql快速复制数据库/","link":"","permalink":"http://machu.club/2017/06/20/2017/06/mysql快速复制数据库/","excerpt":"","text":"某些时候，为了搭建一个测试环境,需要复制一个已存在的MySQL数据库。 创建表 1CREATE DATABASE dbtest DEFAULT CHARACTER SET utf8 COLLATE UTF8_GENERAL_CI; 复制数据库 1mysqldump db -u root -ppassword --add-drop-table | mysql dbtest -u root -ppassword -ppassword : password为密码 如果秘密中有特殊字符需要转译(字符前加上)不然会报(mysqldump: Got error: 1045: Access denied for user ‘root‘@’localhost’ (using password: YES) when trying to connect) 复制到远程另一台MySQL服务器上 1mysqldump db -u root -ppassword --add-drop-table | mysql -h 192.168.1.2 dbtest -u root -ppassword","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://machu.club/tags/Mysql/"}]},{"title":"mysql ip授权","slug":"2017/05/mysql ip授权","date":"2017-05-26T16:00:00.000Z","updated":"2017-05-27T03:37:32.000Z","comments":true,"path":"2017/05/27/2017/05/mysql ip授权/","link":"","permalink":"http://machu.club/2017/05/27/2017/05/mysql ip授权/","excerpt":"","text":"123mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'username'@'127.0.0.1' IDENTIFIED BY 'password' WITH GRANT OPTION;mysql&gt;FLUSH PRIVILEGES; grant语法: grant 权限名（所有的权限用all） on 库名（全部）.表名（全部） to ‘要授权的用户名’@’%’(%表示所有的IP，可以只些一个IP） identified by “密码”；","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://machu.club/tags/Mysql/"}]},{"title":"原型模式","slug":"2017/05/原型模式","date":"2017-05-22T16:00:00.000Z","updated":"2017-07-04T03:38:31.000Z","comments":true,"path":"2017/05/23/2017/05/原型模式/","link":"","permalink":"http://machu.club/2017/05/23/2017/05/原型模式/","excerpt":"","text":"介绍原型模式属于创建型模式的一种,其精髓就在于复制一个存在的实例,而不是去新建。 实例代码我们设想一个这样的场景,小明在X宝上购物,选定购买商品后就要去下订单,我们会发现小明购买多次的订单除了购买商品不同,邮寄地址、收件人、联系方式都是一样的,这时候我们就可以使用原型模型来创建订单了。 Prototype: 实现Cloneable接口(Cloneable就相当于Prototype接口) 重写Object的clone方法,如果不实现Cloneable接口则会抛出CloneNotSupportedException异常 OrderInfo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class OrderInfo implements Cloneable &#123; private String goodsName; private String address; private String username; private String mobile; public String getGoodsName() &#123; return goodsName; &#125; public void setGoodsName(String goodsName) &#123; this.goodsName = goodsName; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; @Override public String toString() &#123; return \"OrderInfo&#123;\" + \"goodsName='\" + goodsName + '\\'' + \", address='\" + address + '\\'' + \", username='\" + username + '\\'' + \", mobile='\" + mobile + '\\'' + '&#125;'; &#125; @Override public OrderInfo clone() throws CloneNotSupportedException &#123; return (OrderInfo) super.clone(); &#125;&#125; Test 12345678910111213141516171819public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; OrderInfo orderInfo = new OrderInfo(); orderInfo.setAddress(\"上海市XXXXX\"); orderInfo.setMobile(\"138XXXXXXXX\"); orderInfo.setUsername(\"小明\"); orderInfo.setGoodsName(\"零食\"); OrderInfo orderInfo1 = orderInfo.clone(); orderInfo1.setGoodsName(\"衣服\"); System.out.println(orderInfo.toString()); System.out.println(orderInfo1.toString()); &#125;&#125; 结果： 12OrderInfo&#123;goodsName='零食', address='上海市XXXXX', username='小明', mobile='138XXXXXXXX'&#125;OrderInfo&#123;goodsName='衣服', address='上海市XXXXX', username='小明', mobile='138XXXXXXXX'&#125; 值得一提的是Object类的clone方法为浅拷贝,关于如何实现深拷贝就是对clone方法进行改造了,有关浅拷贝和深拷贝的相关信息请看下面这篇:浅拷贝和深拷贝","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://machu.club/tags/设计模式/"}]},{"title":"浅拷贝和深拷贝","slug":"2017/05/浅拷贝和深拷贝","date":"2017-05-22T16:00:00.000Z","updated":"2017-05-23T09:31:51.000Z","comments":true,"path":"2017/05/23/2017/05/浅拷贝和深拷贝/","link":"","permalink":"http://machu.club/2017/05/23/2017/05/浅拷贝和深拷贝/","excerpt":"","text":"介绍","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://machu.club/tags/设计模式/"}]},{"title":"建造者模式","slug":"2017/05/建造者模式","date":"2017-05-18T16:00:00.000Z","updated":"2017-07-04T03:38:50.000Z","comments":true,"path":"2017/05/19/2017/05/建造者模式/","link":"","permalink":"http://machu.club/2017/05/19/2017/05/建造者模式/","excerpt":"","text":"介绍建造模式是对象的创建模式。建造模式可以将一个产品的内部表象与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 本模式涉及到四个角色，它们分别是： 产品（Product）角色： 抽象建造者（Builder）角色 具体建造者（ConcreteBuilder）角色 导演者（Director）角色 实例代码Product 12345678910111213141516171819202122public class Product &#123; private String name; private Double price; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125;&#125; Builder 123456789public interface Builder &#123; public void createName(); public void createPrice(); public Product returnProduct();&#125; ConcreteBuilder 12345678910111213141516171819public class ConcreteBuilder implements Builder &#123; private Product product = new Product(); @Override public void createName() &#123; product.setName(\"productName\"); &#125; @Override public void createPrice() &#123; product.setPrice(new Double(100)); &#125; @Override public Product returnProduct() &#123; return product; &#125;&#125; Director 12345678910111213public class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public void construct()&#123; builder.createName(); builder.createPrice(); &#125;&#125; Test 123456789101112public class Test &#123; public static void main(String[] args) &#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.returnProduct(); System.out.println(product.getName()); System.out.println(product.getPrice()); &#125;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://machu.club/tags/设计模式/"}]},{"title":"Linux命令 - chmod","slug":"2017/05/Linux命令 - chmod","date":"2017-05-18T16:00:00.000Z","updated":"2017-05-19T07:01:22.000Z","comments":true,"path":"2017/05/19/2017/05/Linux命令 - chmod/","link":"","permalink":"http://machu.club/2017/05/19/2017/05/Linux命令 - chmod/","excerpt":"","text":"功能：文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。 语法:1chmod [-cfvR] [--help] [--version] mode file... 参数说明:mode: 权限设定字串 1[ugoa...][[+-=][rwxX]...][,...] u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 实例12345#将文件 file1.txt 设为所有人皆可读取chmod ugo+r file1.txt#将目前目录下的所有文件与子目录皆设为任何人可读取 :chmod -R a+r * 此外chmod也可以用数字来表示权限如 : 1chmod 777 file 语法为： 1chmod abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1 若用chmod 4755 filename可使此程序具有root的权限","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://machu.club/tags/Linux/"}]},{"title":"Linux命令 - cat","slug":"2017/05/Linux命令 - cat","date":"2017-05-14T16:00:00.000Z","updated":"2017-05-15T11:47:44.000Z","comments":true,"path":"2017/05/15/2017/05/Linux命令 - cat/","link":"","permalink":"http://machu.club/2017/05/15/2017/05/Linux命令 - cat/","excerpt":"","text":"功能： 显示文件的内容 1cat filename 创建文件 1cat &gt; filename 值得一提的是执行这个命令之后会进入一个输入模式,只会保存回车后的内容 合并内容 1cat file1 file2 &gt; file 将 file1 和 file2 的内容合并到 file 中,按照从左至右的先后顺序,如果 file 已存在则会覆盖 file中的内容 使用权限：所有使用者 参数说明：-n : 输出每行的行数编号 123456$cat -n test 1 This is the 1th line2 3 This is the 3th line4 5 This is the 5th line -b : 和 -n 差不多,只是不输出空白行 123456$cat -b test1 This is the 1th line2 This is the 3th line3 This is the 5th line -s : 将连续两行以上的空白行,用一行空白行来代替 原文件内容(数字为行号)如下 1234567891 This is the 1th line2 3 4 This is the 4th line5 6 7 8 9 This is the 9th line 使用-s输出结果如下 123456$cat -s test This is the 1th lineThis is the 4th lineThis is the 9th line -v : 使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外 -E : 或 –show-ends : 在每行结束处显示 $ -T : 或 –show-tabs: 将 TAB 字符显示为 ^I -A : 等价于 -vET -e : 等价于”-vE”选项 -t : 等价于”-vT”选项","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://machu.club/tags/Linux/"}]},{"title":"Linux命令 - find","slug":"2017/05/Linux命令 - find","date":"2017-05-14T16:00:00.000Z","updated":"2017-05-16T04:50:34.000Z","comments":true,"path":"2017/05/15/2017/05/Linux命令 - find/","link":"","permalink":"http://machu.club/2017/05/15/2017/05/Linux命令 - find/","excerpt":"","text":"功能：在指定目录下查找文件,如果不设置任何参数,则find命令将在当前目录下查找子目录与文件 命令格式：1find pathname -options [-print -exec -ok ...] pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print: find命令将匹配的文件输出到标准输出。 -exec: find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ { } \\;，注意{ }和\\；之间的空格。 -ok: 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执 命令选项：-name : 按照文件名查找文件。 1234find . -name filename#查找当前目录包括子目录及子目录里的目录里以.txt结尾的文件find . -name '*.txt' -perm : 按照文件权限来查找文件。 1find . -perm 755 顺带一提 在linux下权限数字rwx r=4，w=2，x=1 -prune : 使用这一选项可以使find命令不在当前指定的目录中查找,如果同时使用-depth选项，那么-prune将被find命令忽略。 123456789101112#查找当前目录下的子目录及子目录中 名为dir文件夹中以.txt结尾的所有文件find . -path '*dir*' -name '*.txt'#只查找当前目录下 以.txt结尾的文件find . -depth 1 -name '*.txt'find . -maxdepth 1 -name '.txt'#查找当前目录下名为dir的子目录中所有以.txt结尾的文件find . -path './dir*' -name '*.txt'#查找dir目录中除了子目录dir0下其他子目录中以.txtx结尾的所有文件find . -path './dir0' -prune -o -name '*.txt' -print -user : 按照文件属主来查找文件。 1find . -user Helkay -group : 按照文件所属的组来查找文件。 1find . -group staff -mtime -n +n : 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内,+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。 -nogroup : 查找无有效所属组的文件,即该文件所属的组在/etc/groups中不存在。 12#列出/home内不属于本地组的文件或目录find /home -nogroup -nouser : 查找无有效属主的文件,即该文件的属主在/etc/passwd中不存在。 12#列出/home内不属于本地用户的文件或目录 find /home -nouser -newer file1 ! file2 : 查找更改时间比文件file1新但比文件file2旧的文件。 1find /home -newer tmp.txt ! tmp1.txt -type : 查找某一类型的文件,诸如： b - 块设备文件。 d - 目录。 c - 字符设备文件。 p - 管道文件。 l - 符号链接文件。 f - 普通文件。 1find . -type d -size n：[c,k] : 查找文件长度为n块的文件,带有c时表示文件长度以字节计。-depth：在查找文件时,首先查找当前目录中的文件,然后再在其子目录中查找。 12#查找当前目录下(包括子目录)文件大于100k 小于200k 的文件find . -size +100k -size -200k -fstype : 查找位于某一类型文件系统中的文件,这些文件系统类型通常可以在配置文件/etc/fstab中找到,该配置文件中包含了本系统中有关文件系统的信息。 1find / -fstype ext2 -mount : 在查找文件时不跨越文件系统mount点。 -follow : 如果find命令遇到符号链接文件,就跟踪至链接所指向的文件。 -cpio :对匹配的文件使用cpio命令,将这些文件备份到磁带设备中。 另外,下面三个的区别: -amin n : 查找系统中最后N分钟访问的文件 -atime n : 查找系统中最后n*24小时访问的文件 -cmin n : 查找系统中最后N分钟被改变文件状态的文件 -ctime n : 查找系统中最后n*24小时被改变文件状态的文件 -mmin n : 查找系统中最后N分钟被改变文件数据的文件 -mtime n : 查找系统中最后n*24小时被改变文件数据的文件","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://machu.club/tags/Linux/"}]},{"title":"Git命令","slug":"2017/05/Git命令","date":"2017-05-11T16:00:00.000Z","updated":"2017-05-12T10:40:20.000Z","comments":true,"path":"2017/05/12/2017/05/Git命令/","link":"","permalink":"http://machu.club/2017/05/12/2017/05/Git命令/","excerpt":"","text":"Git user.name uesremail设置1234567891011#全局git config --global user.name \"your_name\"git config --global user.emial \"your_email\"#局部git config user.name \"your_name\"git config user.emial \"your_email\"#取消git config --unset --global user.namegit config --unset --global user.email","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://machu.club/tags/Git/"}]},{"title":"Java 注解 Annotations","slug":"2017/05/Java 注解 Annotations","date":"2017-05-10T16:00:00.000Z","updated":"2017-05-12T07:01:21.000Z","comments":true,"path":"2017/05/11/2017/05/Java 注解 Annotations/","link":"","permalink":"http://machu.club/2017/05/11/2017/05/Java 注解 Annotations/","excerpt":"","text":"什么是注解？ 可理解为元数据，即一种描述数据的数据。 1234@Overridepublic String toString() &#123; return \"toString...\";&#125; 在上面的代码中我用Override重写了toString()代码,当然即使我不用注解,程序也是能够正常运行的,但加上了Override注解,它会告诉编译器这是个重写的方法,如果我不小心写错了方法名,而父类中没有该方法,则编译器就会报错。 有关Annotation的一些说明java8 版本在 java.lang.annotation提供了六种元注解(Native和Repeatable是java8加入的，其他的是java5),用来注解其他注解: @Documented : 一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。@Retention : 定义该注解的生命周期。RetentionPolicy.SOURCE 在编译阶段丢弃。 RetentionPolicy.CLASS 在类加载的时候丢弃。 RetentionPolicy.RUNTIME 始终不会丢弃，运行期也保留该注解。 @Target : 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。12345@Retention(RetentionPolicy.SOURCE)@Target(&#123;ElementType.FIELD,ElementType.TYPE,ElementType.METHOD&#125;)public @interface TestTarget &#123;&#125; ElementType.TYPE:用于描述类、接口或enum声明1234567891011121314@TestTargetpublic interface Annotations &#123; &#125;@TestTargetpublic class Annotations &#123;&#125;@TestTargetpublic enum Annotations &#123;&#125; ElementType.FIELD:用于描述实例变量 12345public class Annotations &#123; @TestTarget public String name; &#125; ElementType.METHOD:用于描述方法 12345678public class Annotations &#123; @TestTarget public void test()&#123; &#125;&#125; ElementType.PARAMETER:用于描述参数 1234567public class Annotations &#123; public void test(@TestTarget String name)&#123; &#125;&#125; ElementType.CONSTRUCTOR:用于描述构造方法 123456public class Annotations &#123; @TestTarget public Annotations() &#123; &#125;&#125; ElementType.LOCAL_VARIABLE:用于描述局部变量 12345678public class Annotations &#123; public void test()&#123; @TestTarget String name; &#125;&#125; ElementType.ANNOTATION_TYPE:用于描述另一个注释 1234567public class Annotations &#123; @TestTarget public @interface TestAnnotationType &#123; &#125;&#125; ElementType.PACKAGE 用于记录java文件的package信息 12@TestTargetpackage com.helkay.common; 需要注意的一点是package注解只能写在package-info.java这个文件中 since 1.8 加入 ElementType.TYPE_PARAMETER:用于描述类型参数 123public class Annotation&lt;@TestTarget T&gt; &#123;&#125; ElementType.TYPE_USE:用于描述类型使用12345678910111213141516171819public class Annotation&lt;@TestTarget T&gt; &#123; public List&lt;@TestTarget T&gt; test(@TestTarget String name)&#123; List&lt;@TestTarget T&gt; list1 = new ArrayList&lt;&gt;(); List&lt;? extends T&gt; list2 = new ArrayList&lt;@TestTarget T&gt;(); @TestTarget String text; text = (@TestTarget String)new Object(); java.util. @TestTarget Scanner console; console = new java.util.@TestTarget Scanner(System.in); return new ArrayList&lt;@TestTarget T&gt;(); &#125;&#125; @Inherited : 定义该注释和子类的关系Annotations只支持基本类型、String及枚举类型 12345678910@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@interface TestTarget &#123; public enum Sex &#123;MAN, WOMAN&#125; String author() default \"Helkay\"; Sex sex () default Sex.MAN;&#125; 如何使用: 1234567public class Annotation &#123; @TestTarget( sex = TestTarget.Sex.WOMAN , author = \"Hiko\") public void test()&#123; &#125;&#125; 只有一个属性 1234567@interface TestTarget&#123;String value();&#125;@ TestTarget(\"Helkay\")public void test() &#123;&#125; @Native : 仅仅用来标记native的属性@Repeatable : 可重复注解的注解不使用Repeatable 123456789101112131415public class Annotation &#123; @interface TestTarget &#123; String name(); &#125; @interface TestTargetArr &#123; TestTarget[] value(); &#125; @TestTargetArr(&#123;@TestTarget(name = \"Helkay\"),@TestTarget(name = \"Hiko\")&#125;) public void test()&#123; &#125;&#125; 使用Repeatable 1234567891011121314151617public class Annotation &#123; @Repeatable(TestTargetArr.class) @interface TestTarget &#123; String name(); &#125; @interface TestTargetArr &#123; TestTarget[] value(); &#125; @TestTarget(name = \"Helkay\") @TestTarget(name = \"Hiko\") public void test()&#123; &#125;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://machu.club/tags/Java/"}]},{"title":"ssh登录免密","slug":"2017/05/ssh登录免密","date":"2017-05-09T16:00:00.000Z","updated":"2017-05-12T07:01:12.000Z","comments":true,"path":"2017/05/10/2017/05/ssh登录免密/","link":"","permalink":"http://machu.club/2017/05/10/2017/05/ssh登录免密/","excerpt":"","text":"使用ssh-keygen命令创建密钥对假设 我现在需要在A机(192.168.1.1)上免密ssh登录到B(192.168.1.2)机 在A机用户路径中的.ssh文件夹内创建密钥对 1ssh-keygen -t rsa -f id_rsa.xxx -P '' -f 命名生成的文件名称 -P ‘’ 无密码 （不加则需要输入三次回车） 这时候.ssh文件夹下会生成两个文件(id_rsa.xxx id_rsa.xxx.pub) 将id_rsa.xxx.pub 用scp命令传输的B上 1scp id_rsa.xxx.pub root@192.168.1.2:/(B机上.ssh的路径) 将id_rsa.xxx.pub里的内容写入到 .ssh中的authorized_keys文件中(没有则创建),并修改authorized_keys文件和.ssh文件夹的权限 12345cat id_rsa.xxx.pub&gt;&gt;authorized_keyschmod 600 authorized_keyschmod 700 -R .ssh","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://machu.club/tags/Linux/"}]},{"title":"Intellij idea 远程调试","slug":"2017/05/Intellij Idea远程调试","date":"2017-05-09T16:00:00.000Z","updated":"2017-07-04T03:39:09.000Z","comments":true,"path":"2017/05/10/2017/05/Intellij Idea远程调试/","link":"","permalink":"http://machu.club/2017/05/10/2017/05/Intellij Idea远程调试/","excerpt":"","text":"idea自带的remote tomcat remote 配置server Startup/Connection","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://machu.club/tags/工具/"}]},{"title":"抽象工厂模式","slug":"2017/05/抽象工厂模式","date":"2017-05-05T16:00:00.000Z","updated":"2017-07-04T03:38:55.000Z","comments":true,"path":"2017/05/06/2017/05/抽象工厂模式/","link":"","permalink":"http://machu.club/2017/05/06/2017/05/抽象工厂模式/","excerpt":"","text":"抽象工厂模式介绍产品族: 位于不同产品等级结构中，功能相关联的产品组成的家族 图中GreenCar和RedCar是两个产品树,而GreenJeepCar和GreenSportCar就是一个产品族,他们都是属于Green色的车。同理RedJeepCar和RedSportCar也是一个产品族。 代码实例GreenCar 12345public abstract class GreenCar &#123; public abstract void getColorGreen();&#125; GreenJeepCar 123456public class GreenJeepCar extends GreenCar &#123; @Override public void getColorGreen() &#123; System.out.println(\" Get Color Green \"); &#125;&#125; GreenSportCar 123456public class GreenSportCar extends GreenCar &#123; @Override public void getColorGreen() &#123; System.out.println(\" Get Color Green \"); &#125;&#125; RedCar 12345public abstract class RedCar &#123; public abstract void getColorRed();&#125; RedJeepCar 123456public class RedJeepCar extends RedCar &#123; @Override public void getColorRed() &#123; System.out.println(\" Get Color Red \"); &#125;&#125; RedSportCar 123456public class RedSportCar extends RedCar &#123; @Override public void getColorRed() &#123; System.out.println(\" Get Color Red \"); &#125;&#125; IFactory 1234567public abstract class IFactory &#123; public abstract RedCar createRedCar(); public abstract GreenCar createGreenCar();&#125; JeepFactory 1234567891011121314public class JeepFactory extends IFactory &#123; @Override public RedCar createRedCar() &#123; System.out.println(\" Create Jeep Car \"); return new RedJeepCar(); &#125; @Override public GreenCar createGreenCar() &#123; System.out.println(\" Create Jeep Car \"); return new GreenJeepCar(); &#125;&#125; SportFactory 1234567891011121314public class SportFactory extends IFactory &#123; @Override public RedCar createRedCar() &#123; System.out.println(\" Create Sport Car \"); return new RedSportCar(); &#125; @Override public GreenCar createGreenCar() &#123; System.out.println(\" Create Sport Car \"); return new GreenSportCar(); &#125;&#125; Test 123456789101112public class Test &#123; public static void main(String[] args) &#123; IFactory sportFactory = new SportFactory(); GreenCar greenCar = sportFactory.createGreenCar(); greenCar.getColorGreen(); &#125;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://machu.club/tags/设计模式/"}]},{"title":"工厂方法模式","slug":"2017/05/工厂方法模式","date":"2017-05-03T16:00:00.000Z","updated":"2017-07-04T03:38:45.000Z","comments":true,"path":"2017/05/04/2017/05/工厂方法模式/","link":"","permalink":"http://machu.club/2017/05/04/2017/05/工厂方法模式/","excerpt":"","text":"简单工厂模式介绍简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 代码实例ICar 12345public interface ICar &#123; void getCar(); &#125; JeepCar 12345678public class JeepCar implements ICar &#123; @Override public void getCar() &#123; System.out.println(\"Get JeepCar ...\"); &#125; &#125; SportCar 12345678public class SportCar implements ICar &#123; @Override public void getCar() &#123; System.out.println(\"Get SportCar ...\"); &#125;&#125; Factory 1234567891011121314151617181920212223242526public class Factory &#123; public ICar getInstance(String carType) throws IllegalAccessException, InstantiationException &#123; if(\"sportCat\".equals(carType))&#123; return SportCar.class.newInstance(); &#125;else if(\"jeepCat\".equals(carType))&#123; return JeepCar.class.newInstance(); &#125;else&#123; System.out.println(\"No object is instantiated\"); return null; &#125; &#125; public static void main(String[] args) &#123; Factory factory = new Factory(); try &#123; factory.getInstance(\"sportCat\").getCar(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 工厂方法模式介绍在上面的简单工厂模式中我们将实例化具体对象的工作全部交给了专门负责创建对象的工厂类中,而工厂模式中则让子类决定实例化哪一个类。遵循了开放—封闭原则 代码实例IFactory 12345public interface IFactory &#123; ICar createCar();&#125; JeepFactory 123456789public class JeepFactory implements IFactory &#123; @Override public ICar createCar() &#123; System.out.println(\"JeepCar create ...\"); return new JeepCar(); &#125; &#125; SportFactory 123456789public class SportFactory implements IFactory &#123; @Override public ICar createCar() &#123; System.out.println(\"SportCar create ...\"); return new SportCar(); &#125; &#125; ICar 12345public interface ICar &#123; void getCar();&#125; JeepCar 12345678public class JeepCar implements ICar &#123; @Override public void getCar() &#123; System.out.println(\"Get JeepCar ...\"); &#125;&#125; SprotCar 12345678public class SportCar implements ICar &#123; @Override public void getCar() &#123; System.out.println(\"Get SportCar ...\"); &#125;&#125; Test 1234567891011public class Test &#123; public static void main(String[] args) &#123; IFactory sportFactory = new SportFactory(); ICar sportFactoryCar = sportFactory.createCar(); sportFactoryCar.getCar(); &#125;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://machu.club/tags/设计模式/"}]},{"title":"单例模式","slug":"2017/05/单例模式","date":"2017-05-01T16:00:00.000Z","updated":"2017-05-12T07:00:29.000Z","comments":true,"path":"2017/05/02/2017/05/单例模式/","link":"","permalink":"http://machu.club/2017/05/02/2017/05/单例模式/","excerpt":"","text":"单例模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 懒汉式(线程不安全) 123456789101112131415public class SingletonDemoOne &#123; private static SingletonDemoOne instance; private SingletonDemoOne() &#123; &#125; public static SingletonDemoOne getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemoOne(); //todo &#125; return instance; &#125;&#125; 延迟加载很明显，但是在多线程不能正常工作 懒汉式(线程安全) 123456789101112131415public class SingletonDemoTwo &#123; private static SingletonDemoTwo instance; private SingletonDemoTwo() &#123; &#125; public static synchronized SingletonDemoTwo getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemoTwo(); //todo &#125; return instance; &#125;&#125; 延迟加载明显,但是效率很低 饿汉式 12345678910public class SingletonDemoThree &#123; private static SingletonDemoThree instance = new SingletonDemoThree(); private SingletonDemoThree() &#123; &#125; public static SingletonDemoThree getInstance() &#123; return instance; &#125;&#125; 在类加载的时候实例化,不能确定是否有其他方法导致类加载,且没有达到延迟加载效果 双重检查[推荐使用] 123456789101112131415161718public class SingletonDemoFour &#123; private static volatile SingletonDemoFour singleton; private SingletonDemoFour() &#123; &#125; public static SingletonDemoFour getInstance() &#123; if (singleton == null) &#123; synchronized (SingletonDemoFour.class) &#123; if (singleton == null) &#123; singleton = new SingletonDemoFour(); &#125; &#125; &#125; return singleton; &#125;&#125; 线程安全,延迟加载,效率较高。 静态内部类[推荐使用] 12345678910111213public class SingletonDemoFive &#123; private SingletonDemoFive() &#123; &#125; private static class SingletonInstance &#123; private static final SingletonDemoFive INSTANCE = new SingletonDemoFive(); &#125; public static SingletonDemoFive getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 枚举[推荐使用] 1234567public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://machu.club/tags/设计模式/"}]},{"title":"Java多线程","slug":"2017/05/多线程","date":"2017-05-01T16:00:00.000Z","updated":"2017-05-12T07:00:27.000Z","comments":true,"path":"2017/05/02/2017/05/多线程/","link":"","permalink":"http://machu.club/2017/05/02/2017/05/多线程/","excerpt":"","text":"在写设计模式-单例模式的过程中,我需要本地模拟多线程高并发,所以就有了这个笔记。 名词解释： 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行：多个cpu实例或者多台机器同时执行一段处理逻辑,是真正的同时。 并发：通过cpu调度算法,让用户看上去同时执行,实际上从cpu操作层面不是真正的同时。 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 继承Thread类12345678910111213public class Thread1 extends Thread &#123; public void run() &#123; System.out.println(\"run start!\"); &#125; public static void main(String[] args) &#123; Thread1 t1 = new Thread1(); Thread1 t2 = new Thread1(); t1.start(); t2.start(); &#125;&#125; 实现Runnable类12345678910111213141516171819202122public class Thread2 implements Runnable&#123; @Override public void run() &#123; System.out.println(\"run start!\"); &#125; public static void main(String[] args) &#123; Thread2 t1 = new Thread2(); Thread2 t2 = new Thread2(); Thread thread1 = new Thread(t1); Thread thread2 = new Thread(t2); thread1.start(); thread2.start(); // 简写// new Thread(new Thread2()).start();// new Thread(new Thread2()).start(); &#125;&#125; sleep()和wait()的区别对于这两个方法,首先得明确一点,sleep()方法是属于Thread类的,而wait()方法则是属于Object类的。 主程序中sleep() 1234567891011121314151617181920212223242526272829303132333435public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadDemo1 td1 = new ThreadDemo1(); td1.start(); try &#123; Thread.sleep(3000); //主程序中休眠3s &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ThreadDemo2 td2 = new ThreadDemo2(); td2.start(); &#125; public static String getDate()&#123; SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\"); return sdf.format(new Date()); &#125;&#125;class ThreadDemo1 extends Thread&#123; public void run()&#123; System.out.println(ThreadTest.getDate() + \" -- ThreadDemo1 start run...\"); &#125;&#125;class ThreadDemo2 extends Thread&#123; public void run()&#123; System.out.println(ThreadTest.getDate() + \" -- ThreadDemo2 start run...\"); &#125;&#125; 结果： 1215:48:25 -- ThreadDemo1 start run...15:48:28 -- ThreadDemo2 start run... 线程中sleep() 1234567891011121314151617181920212223242526272829303132333435363738public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadDemo1 td1 = new ThreadDemo1(); td1.start(); ThreadDemo2 td2 = new ThreadDemo2(); td2.start(); &#125; public static String getDate()&#123; SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\"); return sdf.format(new Date()); &#125;&#125;class ThreadDemo1 extends Thread&#123; public void run()&#123; try &#123; System.out.println(ThreadTest.getDate() + \" -- ThreadDemo1 start sleep...\"); Thread.sleep(3000); System.out.println(ThreadTest.getDate() + \" -- ThreadDemo1 start run...\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ThreadDemo2 extends Thread&#123; public void run()&#123; synchronized (ThreadTest.class)&#123; System.out.println(ThreadTest.getDate() + \" -- ThreadDemo2 start run...\"); &#125; &#125;&#125; 结果： 12315:57:52 -- ThreadDemo1 start sleep...15:57:52 -- ThreadDemo2 start run...15:57:55 -- ThreadDemo1 start run... sleep()导致的是程序暂停指定的时间,线程不会释放对象锁。 wait()的测试Demo 123456789101112131415161718192021222324252627282930313233343536373839404142public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadDemo1 td1 = new ThreadDemo1(); td1.start(); ThreadDemo2 td2 = new ThreadDemo2(); td2.start(); &#125; public static String getDate() &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\"); return sdf.format(new Date()); &#125;&#125;class ThreadDemo1 extends Thread &#123; public void run() &#123; synchronized (ThreadTest.class) &#123; try &#123; System.out.println(ThreadTest.getDate() + \" -- ThreadDemo1 start wait...\"); ThreadTest.class.wait(); System.out.println(ThreadTest.getDate() + \" -- ThreadDemo1 start run...\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class ThreadDemo2 extends Thread &#123; public void run() &#123; synchronized (ThreadTest.class) &#123; System.out.println(ThreadTest.getDate() + \" -- ThreadDemo2 start run...\"); ThreadTest.class.notify(); &#125; &#125;&#125; 结果： 12317:05:43 -- ThreadDemo1 start wait...17:05:43 -- ThreadDemo2 start run...17:05:43 -- ThreadDemo1 start run... ThreadDemo1 wait后将资源让给了 ThreadDemo2, ThreadDemo2执行完后唤醒了ThreadDemo1","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://machu.club/tags/多线程/"}]},{"title":"删除远程分支","slug":"2017/04/删除远程分支","date":"2017-04-24T16:00:00.000Z","updated":"2017-05-12T07:00:34.000Z","comments":true,"path":"2017/04/25/2017/04/删除远程分支/","link":"","permalink":"http://machu.club/2017/04/25/2017/04/删除远程分支/","excerpt":"","text":"1git push origin --delete &lt;branch name&gt;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://machu.club/tags/Git/"}]},{"title":"修改提交注释信息","slug":"2017/04/修改提交注释信息","date":"2017-04-24T16:00:00.000Z","updated":"2017-05-12T07:00:36.000Z","comments":true,"path":"2017/04/25/2017/04/修改提交注释信息/","link":"","permalink":"http://machu.club/2017/04/25/2017/04/修改提交注释信息/","excerpt":"","text":"如何修改现有的，未被提交的提交？1git commit --amend OR 1git commit --amend -m &quot;New commit message&quot; 如果您已经推你的提交到你的远程分支,那么就需要强行提交1git push &lt;remote&gt; &lt;branch&gt; --force OR 1git push &lt;remote&gt; &lt;branch&gt; -f 警告：强制推送会用本地状态覆盖远程分支。如果远程分支上有您在本地分支机构没有的提交，那么您将丢失这些提交。 更多详情: stackoverflow","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://machu.club/tags/Git/"}]},{"title":"nginx session保持","slug":"2017/04/nginx 配置 session保持","date":"2017-04-17T16:00:00.000Z","updated":"2017-05-12T07:00:39.000Z","comments":true,"path":"2017/04/18/2017/04/nginx 配置 session保持/","link":"","permalink":"http://machu.club/2017/04/18/2017/04/nginx 配置 session保持/","excerpt":"","text":"今天在使用JCaptcha做验证码功能的时候,在本地是可以正常验证的,可是发布在服务器上的时候验证码功能就失效了,于是打上日志,看输出信息,发现验证码生成的时候从session里取的id跟校验的时候从session的id不同,发生了改变. 由于我的服务器上用了nginx,去网上查,很多都是讲的是负载均衡导致的session不共享,需配置 1234upstream cms&#123; server 127.0.0.1:8080; ip_hash;&#125; 但是由于我只用了一个服务,再查找了一下资料,发现主要是cookie路径的转换问题,如果只是host、端口转换，则cookie不会丢失,如果路径也变化了，则需要设置cookie的路径转换，nginx.conf的配置如下 1234location /proxy_path &#123; proxy_pass http://127.0.0.1:8080/project; proxy_cookie_path /project /proxy_path;&#125;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://machu.club/tags/Nginx/"}]},{"title":"@ResponseBody 返回字符串乱码","slug":"2017/04/@ResponseBody 返回字符串乱码","date":"2017-04-05T16:00:00.000Z","updated":"2017-05-12T07:00:42.000Z","comments":true,"path":"2017/04/06/2017/04/@ResponseBody 返回字符串乱码/","link":"","permalink":"http://machu.club/2017/04/06/2017/04/@ResponseBody 返回字符串乱码/","excerpt":"","text":"今天在用ajax post方法调用java方法时,返回的结果中文始终是???这种格式。一开始我以为是response没有转码导致的,但是java代码中加入转码后依然无效1response.setCharacterEncoding(\"UTF-8\"); 最后查资料发现是spring mvc的一个bug，spring MVC有一系列HttpMessageConverter去处理用@ResponseBody注解的返回值，如返回list则使用MappingJacksonHttpMessageConverter，返回string，则使用StringHttpMessageConverter，这个convert使用的是字符集是iso-8859-1,而且是final的网上目前我找到的有两种解决办法 自己继承AbstractHttpMessageConverter,写一个类复制 StringHttpMessageConverter.java的代码,将public static final Charset DEFAULT_CHARSET = Charset.forName(“ISO-8859-1”);改为public static final Charset DEFAULT_CHARSET = Charset.forName(“UTF-8”);spring-servlet的配置文件如下 12345678&lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"com.renren001.converter.UTF8StringHttpMessageConverter\" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; StringHttpMessageConverter默认iso-8859-1编码，但是会根据请求头信息指定的编码格式来转换，所以只需要在ajax请求的时候指定头信息Accept属性$.ajax({…headers: {Accept : “text/plain; charset=utf-8”,}});","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://machu.club/tags/Java/"}]},{"title":"quartz定时功能","slug":"2017/03/quartz定时功能","date":"2017-03-23T16:00:00.000Z","updated":"2017-05-12T07:00:46.000Z","comments":true,"path":"2017/03/24/2017/03/quartz定时功能/","link":"","permalink":"http://machu.club/2017/03/24/2017/03/quartz定时功能/","excerpt":"","text":"quartz定时器配置文件定时配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"executor\" class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\"&gt; &lt;property name=\"corePoolSize\" value=\"10\" /&gt; &lt;property name=\"maxPoolSize\" value=\"100\" /&gt; &lt;property name=\"queueCapacity\" value=\"500\" /&gt; &lt;/bean&gt; &lt;!-- spring自动任务调度器配置 --&gt; &lt;!-- 要调用的工作类 --&gt; &lt;bean id=\"job1\" class=\"com.***.***.quartz.SpringQtz\"&gt;&lt;/bean&gt; &lt;bean id=\"jobTask1\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;!-- 调用的类 --&gt; &lt;property name=\"targetObject\"&gt; &lt;ref bean=\"job1\"/&gt; &lt;/property&gt; &lt;!-- 调用类中的方法 --&gt; &lt;property name=\"targetMethod\"&gt; &lt;value&gt;qtzTest&lt;/value&gt; &lt;/property&gt; &lt;!-- 是否允许任务并发执行。当值为false时，表示必须等到前一个线程处理完毕后才再启一个新的线程 --&gt; &lt;property name=\"concurrent\" value=\"false\"/&gt; &lt;/bean&gt; &lt;!-- 触发器配置 时间指定 --&gt; &lt;bean id=\"cronTrigger1\" class=\"org.springframework.scheduling.quartz.CronTriggerBean\"&gt; &lt;property name=\"jobDetail\" ref=\"jobTask1\"&gt;&lt;/property&gt; &lt;!-- cron表达式 --&gt; &lt;property name=\"cronExpression\"&gt; &lt;!-- 每隔10秒执行一次 --&gt; &lt;value&gt;0/10 * * * * ?&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 总管理类 如果将lazy-init='false'那么容器启动就会执行调度程序 --&gt; &lt;bean id=\"startQuertz\" lazy-init=\"false\" autowire=\"no\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;!-- 触发器列表 --&gt; &lt;ref bean=\"cronTrigger1\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; spring引入配置文件1&lt;import resource=\"spring-timer.xml\" /&gt;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"定时器","slug":"定时器","permalink":"http://machu.club/tags/定时器/"}]},{"title":"签名与加密技术","slug":"2017/03/签名与加密技术","date":"2017-03-22T16:00:00.000Z","updated":"2017-05-12T07:00:49.000Z","comments":true,"path":"2017/03/23/2017/03/签名与加密技术/","link":"","permalink":"http://machu.club/2017/03/23/2017/03/签名与加密技术/","excerpt":"","text":"签名普通数字签名最常用的算法为RSARSA原理：RSA算法基于一个十分简单的数论事实，将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 RSA缺点：RSA的keysize位数越高，其产生密钥对及加密、解密的速度越慢，这是基于大素数非对称加密算法的缺陷。 公钥与私钥一般，我们可以用RSA算法生成一对密钥，公钥发放给外部客户，私钥自己保管；有以下一些应用场景: 公钥加密、私钥解密 私钥加密、公钥验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * * @ClassName: SignatureData * @Description: RSAWithMD5/RSAWithSHA1/RSAWithSHA256签名提供类 */public class SignatureData &#123; /** * 加密 * * @param byteContent 待加密内容 * @param prikeyvalue 私钥 * @param algorithmType 加密算法 * @return */ public static byte[] encrypt(byte[] byteContent, String securityType,String prikeyvalue,String algorithmType) &#123; try &#123; PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(SecurityUtils.hexStrToBytes(prikeyvalue)); KeyFactory keyf = KeyFactory.getInstance(algorithmType); PrivateKey myprikey = keyf.generatePrivate(priPKCS8); // 用私钥对信息生成数字签名 java.security.Signature signet = java.security.Signature.getInstance(securityType); signet.initSign(myprikey); signet.update(byteContent); return signet.sign(); // 对信息的数字签名 &#125; catch (java.lang.Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 验签 * @param src 源内容 * @param content 加密内容 * @param securityType 加密类型 * @param pubkeyvalue 公钥 * @param algorithmType 加密算法 * @return */ public static boolean signetCheck(String src, byte[] content, String securityType, String pubkeyvalue,String algorithmType) &#123; try &#123; X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(SecurityUtils.hexStrToBytes(pubkeyvalue)); KeyFactory keyFactory = KeyFactory.getInstance(algorithmType); PublicKey pubKey = keyFactory.generatePublic(bobPubKeySpec); java.security.Signature signetcheck = java.security.Signature.getInstance(securityType); signetcheck.initVerify(pubKey); signetcheck.update(src.getBytes()); if (signetcheck.verify(content)) &#123; System.out.println(\"签名正常\"); return true; &#125; else &#123; System.out.println(\"非签名正常\"); return false; &#125; &#125; catch (java.lang.Exception e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 加密AES对称加密","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://machu.club/tags/Java/"}]},{"title":"Maven学习笔记","slug":"2017/03/Maven学习笔记","date":"2017-03-15T16:00:00.000Z","updated":"2017-05-12T07:00:51.000Z","comments":true,"path":"2017/03/16/2017/03/Maven学习笔记/","link":"","permalink":"http://machu.club/2017/03/16/2017/03/Maven学习笔记/","excerpt":"","text":"打印整个依赖树1mvn dependency:tree","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://machu.club/tags/Maven/"}]},{"title":"mysql数据库无法插入中文","slug":"2017/03/mysql数据库无法插入中文","date":"2017-03-09T16:00:00.000Z","updated":"2017-05-12T07:00:55.000Z","comments":true,"path":"2017/03/10/2017/03/mysql数据库无法插入中文/","link":"","permalink":"http://machu.club/2017/03/10/2017/03/mysql数据库无法插入中文/","excerpt":"","text":"MySQL中，数据库的编码是一个相当重要的问题，有时候我们需要查看一下当前数据库的编码，甚至需要修改一下数据库编码。 修改my.cnf 12345[mysqld]character-set-server=utf8[client]default-character-set=utf8 ####查看数据库信息123mysql &gt; show variables;mysql &gt; set names &apos;gbk&apos;; 123456&apos;character_set_connection&apos;, &apos;gbk&apos;&apos;character_set_database&apos;, &apos;utf8&apos;&apos;character_set_filesystem&apos;, &apos;binary&apos;&apos;character_set_results&apos;, &apos;gbk&apos;&apos;character_set_server&apos;, &apos;utf8&apos;&apos;character_set_system&apos;, &apos;utf8&apos; 修改完毕后重建表加上 character set utf8;","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://machu.club/tags/Mysql/"}]},{"title":"分支回退","slug":"2016/12/分支回退","date":"2016-12-05T16:00:00.000Z","updated":"2017-05-12T07:00:57.000Z","comments":true,"path":"2016/12/06/2016/12/分支回退/","link":"","permalink":"http://machu.club/2016/12/06/2016/12/分支回退/","excerpt":"","text":"本地分支回退查看本地版本信息 1git reflog 回退版本 1git reset --hard 版本号 远程分支回退远程分支回退同本地回退,只需在回退版本操作后推送到远程分支 1git push -f","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://machu.club/tags/Git/"}]},{"title":"Linux rm命令详解","slug":"2016/11/linux-rm","date":"2016-11-28T16:00:00.000Z","updated":"2017-05-12T07:01:00.000Z","comments":true,"path":"2016/11/29/2016/11/linux-rm/","link":"","permalink":"http://machu.club/2016/11/29/2016/11/linux-rm/","excerpt":"","text":"rm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。 注意：使用rm命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm命令可以用-i选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入y并按Enter键，才能删除文件。如果仅按Enter键或其他字符，文件不会被删除。 删除指定类型结尾的文件方法一:1find ./ -name &quot;*.txt&quot; | xargs rm 方法二:1find . -name &apos;*.exe&apos; -type f -print -exec rm -rf &#123;&#125; \\ “.” 表示从当前目录开始递归查找 -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件 “ -type f “查找的类型为文件 “-print” 输出查找的文件目录名 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\\，最后是一个分号","categories":[{"name":"Blog","slug":"Blog","permalink":"http://machu.club/categories/Blog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://machu.club/tags/Linux/"}]}]}